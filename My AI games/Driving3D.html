<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<title>Mini 3D Driving Game — All in HTML</title>
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				overflow: hidden;
				font-family: Segoe UI, Arial, sans-serif;
				background: #111;
				color: #fff;
			}
			#container {
				position: fixed;
				inset: 0;
			}
			#hud {
				position: absolute;
				left: 12px;
				top: 12px;
				z-index: 10;
				background: rgba(0, 0, 0, 0.35);
				padding: 10px;
				border-radius: 8px;
				min-width: 160px;
				backdrop-filter: blur(3px);
			}
			#hud h1 {
				margin: 0 0 6px 0;
				font-size: 16px;
			}
			#speed {
				font-size: 22px;
				font-weight: 700;
			}
			#lap {
				margin-top: 6px;
				font-size: 14px;
			}
			#controls {
				position: absolute;
				right: 12px;
				top: 12px;
				background: rgba(0, 0, 0, 0.35);
				padding: 10px;
				border-radius: 8px;
			}
			.small {
				font-size: 12px;
				opacity: 0.9;
			}
			#message {
				position: absolute;
				left: 50%;
				top: 20%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.7);
				padding: 12px 18px;
				border-radius: 8px;
				font-size: 18px;
				display: none;
				z-index: 11;
			}
			canvas {
				display: block;
			}
			#minimap {
				position: absolute;
				right: 12px;
				bottom: 12px;
				width: 180px;
				height: 120px;
				background: rgba(0, 0, 0, 0.35);
				border-radius: 8px;
				padding: 6px;
			}
			#minimap canvas {
				width: 100%;
				height: 100%;
				display: block;
				background: #0b0b0b;
				border-radius: 6px;
			}
			a.small {
				color: #90ee90;
				text-decoration: none;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>

		<div id="hud">
			<h1>3D Drive</h1>
			<div id="speed">Speed: 0 km/h</div>
			<div id="lap">Lap: 0 / 3</div>
			<div class="small" style="margin-top: 6px">
				W/S or ↑/↓ to accelerate/brake — A/D or ←/→ to steer — R to
				reset
			</div>
		</div>

		<div id="controls" class="small">
			<div>Time: <span id="time">0.00</span>s</div>
			<div style="margin-top: 6px">
				Checkpoints: <span id="cp">0</span>/<span id="cpTotal">0</span>
			</div>
		</div>

		<div id="message"></div>

		<div id="minimap">
			<canvas id="mm" width="360" height="240"></canvas>
		</div>

		<!-- Three.js from CDN -->
		<script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
		<script>
			// ---------- Simple 3D Driving Game ----------
			// Highly-commented so you can tweak things in VSCode.
			(function () {
				const container = document.getElementById("container");
				const messageEl = document.getElementById("message");
				const speedEl = document.getElementById("speed");
				const lapEl = document.getElementById("lap");
				const timeEl = document.getElementById("time");
				const cpEl = document.getElementById("cp");
				const cpTotalEl = document.getElementById("cpTotal");

				// Renderer
				const renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMap.enabled = true;
				container.appendChild(renderer.domElement);

				// Scene & Camera
				const scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2(0x101218, 0.0022);
				const camera = new THREE.PerspectiveCamera(
					60,
					window.innerWidth / window.innerHeight,
					0.1,
					2000
				);
				camera.position.set(0, 6, -12);

				// Lights
				const hemi = new THREE.HemisphereLight(0xbfdfff, 0x404040, 0.6);
				scene.add(hemi);
				const dir = new THREE.DirectionalLight(0xffffff, 0.8);
				dir.position.set(10, 20, 10);
				dir.castShadow = true;
				dir.shadow.mapSize.set(2048, 2048);
				dir.shadow.camera.near = 1;
				dir.shadow.camera.far = 100;
				dir.shadow.camera.left = -40;
				dir.shadow.camera.right = 40;
				dir.shadow.camera.top = 40;
				dir.shadow.camera.bottom = -40;
				scene.add(dir);

				// Ground
				const groundMat = new THREE.MeshStandardMaterial({
					color: 0x2b7a2b,
					roughness: 1,
				});
				const ground = new THREE.Mesh(
					new THREE.PlaneGeometry(1200, 1200),
					groundMat
				);
				ground.rotation.x = -Math.PI / 2;
				ground.receiveShadow = true;
				scene.add(ground);

				// Road (simple loop)
				const road = new THREE.Mesh(
					new THREE.PlaneGeometry(240, 18),
					new THREE.MeshStandardMaterial({ color: 0x333333 })
				);
				road.rotation.x = -Math.PI / 2;
				road.position.y = 0.01;
				scene.add(road);

				// Curved track path (using circle + a few straight segments via geometry)
				const trackPoints = [];
				const radius = 60;
				for (let a = 0; a < Math.PI * 2; a += Math.PI / 32) {
					const x =
						Math.cos(a) * radius * (1 + 0.18 * Math.sin(4 * a));
					const z = Math.sin(a) * radius;
					trackPoints.push(new THREE.Vector3(x, 0, z));
				}
				// Visualize track (thin line)
				const trackGeom = new THREE.BufferGeometry().setFromPoints(
					trackPoints
				);
				const trackLine = new THREE.Line(
					trackGeom,
					new THREE.LineBasicMaterial({ color: 0xffffaa })
				);
				trackLine.rotation.x = -Math.PI / 2;
				scene.add(trackLine);

				// Add some obstacles / cones
				const coneGeo = new THREE.ConeGeometry(0.7, 1.6, 8);
				const coneMat = new THREE.MeshStandardMaterial({
					color: 0xff5500,
				});
				const obstacles = [];
				for (let i = 0; i < 18; i++) {
					const p =
						trackPoints[
							Math.floor(Math.random() * trackPoints.length)
						];
					const cone = new THREE.Mesh(coneGeo, coneMat);
					cone.position.set(
						p.x + (Math.random() - 0.5) * 8,
						0.8,
						p.z + (Math.random() - 0.5) * 8
					);
					cone.castShadow = true;
					scene.add(cone);
					obstacles.push(cone);
				}

				// Checkpoints (place a few around track)
				const checkpoints = [];
				const cpCount = 5;
				for (let i = 0; i < cpCount; i++) {
					const idx = Math.floor((i * trackPoints.length) / cpCount);
					const p = trackPoints[idx];
					const ring = new THREE.Mesh(
						new THREE.TorusGeometry(6, 0.2, 8, 48),
						new THREE.MeshBasicMaterial({ color: 0x66ccff })
					);
					ring.rotation.x = Math.PI / 2;
					ring.position.set(p.x, 2.6, p.z);
					ring.userData = { index: i };
					scene.add(ring);
					checkpoints.push(ring);
				}
				cpTotalEl.textContent = checkpoints.length;

				// Car (box + four cylinders)
				const car = new THREE.Group();
				const body = new THREE.Mesh(
					new THREE.BoxGeometry(2.8, 0.9, 4.8),
					new THREE.MeshStandardMaterial({ color: 0x1e90ff })
				);
				body.position.y = 1.1;
				body.castShadow = true;
				car.add(body);

				const wheelGeo = new THREE.CylinderGeometry(
					0.45,
					0.45,
					0.6,
					16
				);
				const wheelMat = new THREE.MeshStandardMaterial({
					color: 0x111111,
				});
				function makeWheel(x, z) {
					const w = new THREE.Mesh(wheelGeo, wheelMat);
					w.rotation.z = Math.PI / 2;
					w.position.set(x, 0.45, z);
					w.castShadow = true;
					car.add(w);
					return w;
				}
				const w1 = makeWheel(-1.1, -1.6);
				const w2 = makeWheel(1.1, -1.6);
				const w3 = makeWheel(-1.1, 1.6);
				const w4 = makeWheel(1.1, 1.6);

				car.position.set(trackPoints[0].x, 0, trackPoints[0].z);
				car.rotation.y =
					Math.atan2(
						trackPoints[1].x - trackPoints[0].x,
						trackPoints[1].z - trackPoints[0].z
					) + Math.PI;
				car.castShadow = true;
				scene.add(car);

				// Simple driving state
				let velocity = 0; // forward speed (units/s)
				let steering = 0; // radians
				const maxSpeed = 90000; // km/h equivalent scaled (game units) -- MODIFIED
				const maxVel = 22; // world units per second
				const accel = 100; // acceleration units
				const brake = 40;
				const steerSpeed = 1.9; // steering responsiveness

				// Input
				const keys = {};
				window.addEventListener("keydown", (e) => {
					keys[e.key.toLowerCase()] = true;
					if (e.key === "r" || e.key === "R") resetCar();
				});
				window.addEventListener("keyup", (e) => {
					keys[e.key.toLowerCase()] = false;
				});

				// Car state & game state
				let lap = 0;
				let currentCp = 0;
				let time = 0;
				let gameStarted = false;
				let lastTimestamp = 0;

				function resetCar() {
					velocity = 0;
					car.position.set(trackPoints[0].x, 0, trackPoints[0].z);
					car.rotation.y =
						Math.atan2(
							trackPoints[1].x - trackPoints[0].x,
							trackPoints[1].z - trackPoints[0].z
						) + Math.PI;
					currentCp = 0;
					lap = 0;
					time = 0;
					gameStarted = false;
					showMessage("Game Reset", 1.5);
					cpEl.textContent = 0;
					lapEl.textContent = `Lap: 0 / 3`;
					timeEl.textContent = `0.00`;
				}

				// Collision detection (simple distance check with cones)
				function checkCollisions() {
					for (const cone of obstacles) {
						if (car.position.distanceTo(cone.position) < 2) {
							// Push car away from cone
							const dir = car.position
								.clone()
								.sub(cone.position)
								.normalize();
							car.position.add(dir.multiplyScalar(0.01));
							// Slow down car
							velocity *= 0.96;
						}
					}
				}

				// Checkpoint detection (simple distance check with rings)
				function checkCheckpoints() {
					const nextCp = checkpoints[currentCp];
					if (car.position.distanceTo(nextCp.position) < 6) {
						if (currentCp === checkpoints.length - 1) {
							// Last checkpoint, start new lap
							lap++;
							currentCp = 0;
							showMessage(
								`Lap ${lap} of 3 completed!`,
								2,
								"green"
							);
							if (lap === 3) {
								showMessage(
									"Race Finished! Time: " +
										time.toFixed(2) +
										"s",
									999,
									"gold"
								);
								gameStarted = false;
							}
						} else {
							currentCp++;
							showMessage(
								`Checkpoint ${currentCp} of ${checkpoints.length} reached!`,
								1
							);
						}
						cpEl.textContent = currentCp;
						lapEl.textContent = `Lap: ${lap} / 3`;
					}
				}

				function showMessage(text, duration, color) {
					messageEl.style.display = "block";
					messageEl.style.color = color || "white";
					messageEl.textContent = text;
					clearTimeout(messageEl.timer);
					if (duration !== 999) {
						messageEl.timer = setTimeout(() => {
							messageEl.style.display = "none";
						}, duration * 1000);
					}
				}

				// Minimap (Canvas)
				const mmCanvas = document.getElementById("mm");
				const mmCtx = mmCanvas.getContext("2d");
				const mmScale = 1.5; // Adjusted scale for a clearer minimap

				function drawMinimap() {
					mmCtx.clearRect(0, 0, mmCanvas.width, mmCanvas.height);
					mmCtx.save();
					mmCtx.translate(
						mmCanvas.width / 2,
						mmCanvas.height / 2 + 10
					);
					mmCtx.scale(mmScale, mmScale);

					// Draw track
					mmCtx.strokeStyle = "#ffffaa";
					mmCtx.lineWidth = 1;
					mmCtx.beginPath();
					for (let i = 0; i < trackPoints.length; i++) {
						const p = trackPoints[i];
						if (i === 0) {
							mmCtx.moveTo(p.x, p.z);
						} else {
							mmCtx.lineTo(p.x, p.z);
						}
					}
					mmCtx.closePath();
					mmCtx.stroke();

					// Draw car
					mmCtx.fillStyle = "white";
					mmCtx.beginPath();
					mmCtx.arc(
						car.position.x,
						car.position.z,
						1.5 / mmScale,
						0,
						Math.PI * 2
					);
					mmCtx.fill();

					// Draw checkpoints
					mmCtx.strokeStyle = "#66ccff";
					mmCtx.lineWidth = 2 / mmScale;
					checkpoints.forEach((cp, i) => {
						if (i >= currentCp) {
							mmCtx.beginPath();
							mmCtx.arc(
								cp.position.x,
								cp.position.z,
								2.5 / mmScale,
								0,
								Math.PI * 2
							);
							mmCtx.stroke();
						}
					});

					mmCtx.restore();
				}

				// Main game loop
				function animate(timestamp) {
					const delta = (timestamp - lastTimestamp) / 1000;
					lastTimestamp = timestamp;

					// Game Logic (only runs if started)
					if (gameStarted) {
						// Update time
						time += delta;
						timeEl.textContent = time.toFixed(2);

						// Car controls
						if (keys.w || keys.arrowup) velocity += accel * delta;
						if (keys.s || keys.arrowdown) velocity -= brake * delta;
						if (keys.a || keys.arrowleft)
							steering += steerSpeed * delta;
						if (keys.d || keys.arrowright)
							steering -= steerSpeed * delta;

						// Limit speed
						velocity = Math.max(0, Math.min(velocity, maxVel));

						// Update car position based on velocity and steering
						car.rotation.y +=
							steering * delta * (velocity / maxVel);
						car.position.x +=
							Math.sin(car.rotation.y) * velocity * delta;
						car.position.z +=
							Math.cos(car.rotation.y) * velocity * delta;

						// Dampen steering
						steering *= 0.92;
						// Apply braking friction
						velocity *= 0.98;

						// Check for collisions and checkpoints
						checkCollisions();
						checkCheckpoints();
					} else {
						if (
							keys.w ||
							keys.s ||
							keys.arrowup ||
							keys.arrowdown
						) {
							gameStarted = true;
							showMessage("Go!", 1.5, "cyan");
							lastTimestamp = timestamp; // Reset timer for accurate start
						}
					}

					// Update camera
					camera.lookAt(car.position);
					camera.position.x =
						car.position.x - 10 * Math.sin(car.rotation.y);
					camera.position.z =
						car.position.z - 10 * Math.cos(car.rotation.y);
					camera.position.y = 6;

					// Render
					renderer.render(scene, camera);
					speedEl.textContent = `Speed: ${(
						(velocity / maxVel) *
						maxSpeed
					).toFixed(0)} km/h`; // Display scaled speed
					drawMinimap();

					requestAnimationFrame(animate);
				}

				requestAnimationFrame(animate);

				// Handle window resize
				window.addEventListener("resize", () => {
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(window.innerWidth, window.innerHeight);
				});

				// Initial message
				showMessage("Press W or ↑ to start", 999, "cyan");
			})();
		</script>
	</body>
</html>
