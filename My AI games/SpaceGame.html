<!DOCTYPE html>
<html>
	<head>
		<title>Space Shooter</title>
		<style>
			body {
				background-color: black;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				font-family: monospace;
				color: white;
				text-align: center;
			}
			canvas {
				background-color: #000;
				border: 2px solid white;
			}
			h1 {
				position: absolute;
				top: 50px;
				font-size: 3em;
				text-shadow: 2px 2px 5px #00f;
			}
		</style>
	</head>
	<body>
		<h1>Space Shooter</h1>
		<canvas id="gameCanvas" width="800" height="600"></canvas>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			// Game objects
			let player;
			let enemies = [];
			let projectiles = [];
			let score = 0;
			let level = 1;
			let isGameOver = false;
			let enemySpawnTimer = 0;

			const projectileSpeed = 7;
			let enemySpeed = 1;

			// Autoclicker variables
			let autoclickerEnabled = false;
			let autoclickerInterval;

			// Classes for game objects
			class Player {
				constructor() {
					this.width = 50;
					this.height = 30;
					this.x = canvas.width / 2 - this.width / 2;
					this.y = canvas.height - this.height - 20;
					this.speedX = 0;
					this.speedY = 0;
					this.playerSpeed = 5;
				}

				draw() {
					ctx.fillStyle = "cyan";
					ctx.beginPath();
					ctx.moveTo(this.x, this.y + this.height);
					ctx.lineTo(this.x + this.width / 2, this.y);
					ctx.lineTo(this.x + this.width, this.y + this.height);
					ctx.closePath();
					ctx.fill();
				}

				update() {
					this.x += this.speedX;
					if (this.x < 0) this.x = 0;
					if (this.x + this.width > canvas.width)
						this.x = canvas.width - this.width;
				}

				shoot() {
					projectiles.push(
						new Projectile(
							this.x + this.width / 2,
							this.y,
							0, // speedX
							-projectileSpeed // speedY
						)
					);
				}

				shoot360() {
					const numBullets = 20; // Number of bullets to fire in a circle
					const angleStep = (Math.PI * 2) / numBullets;
					for (let i = 0; i < numBullets; i++) {
						const angle = i * angleStep;
						const speedX = Math.cos(angle) * projectileSpeed;
						const speedY = Math.sin(angle) * projectileSpeed;
						projectiles.push(
							new Projectile(
								this.x + this.width / 2,
								this.y + this.height / 2,
								speedX,
								speedY
							)
						);
					}
				}
			}

			class Projectile {
				constructor(x, y, speedX, speedY) {
					this.x = x;
					this.y = y;
					this.radius = 3;
					this.speedX = speedX;
					this.speedY = speedY;
				}

				draw() {
					ctx.fillStyle = "white";
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
					ctx.fill();
				}

				update() {
					this.x += this.speedX;
					this.y += this.speedY;
				}
			}

			class Enemy {
				constructor(x, y) {
					this.width = 40;
					this.height = 30;
					this.x = x;
					this.y = y;
				}

				draw() {
					ctx.fillStyle = "red";
					ctx.fillRect(this.x, this.y, this.width, this.height);
				}

				update() {
					this.y += enemySpeed;
				}
			}

			function createEnemies() {
				const enemyCols = 8 + Math.min(level - 1, 4); // Up to 12 columns
				const enemyRows = 4 + Math.min(level - 1, 3); // Up to 7 rows
				const enemyPadding = 50 - Math.min(level - 1, 2) * 5; // Reduced spacing
				const startX = (canvas.width - enemyCols * enemyPadding) / 2;

				for (let row = 0; row < enemyRows; row++) {
					for (let col = 0; col < enemyCols; col++) {
						enemies.push(
							new Enemy(
								startX + col * enemyPadding,
								row * enemyPadding + 50
							)
						);
					}
				}
			}

			function init() {
				player = new Player();
				enemies = [];
				projectiles = [];
				level = 1;
				score = 0;
				enemySpeed = 1;
				createEnemies();
				isGameOver = false;
				stopAutoclicker();
			}

			function nextLevel() {
				level++;
				// Increase enemy speed for the next level, maxing out at a certain value
				enemySpeed = 1 + Math.min(level - 1, 5) * 0.5;
				enemies = [];
				projectiles = [];
				createEnemies();
				isGameOver = false; // Reset to continue the game
				stopAutoclicker();
			}

			// Input handling
			document.addEventListener("keydown", (e) => {
				if (isGameOver) {
					if (e.key === "Enter") {
						restartGame();
					}
					return;
				}
				if (e.key === "ArrowLeft") player.speedX = -player.playerSpeed;
				if (e.key === "ArrowRight") player.speedX = player.playerSpeed;
				if (e.key === " ") {
					e.preventDefault();
					if (!autoclickerEnabled) {
						player.shoot();
					}
				}
				if (e.key === "Control") {
					e.preventDefault();
					toggleAutoclicker();
				}
				if (e.key === "m" || e.key === "M") {
					player.shoot360();
				}
			});

			document.addEventListener("keyup", (e) => {
				if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
					player.speedX = 0;
				}
			});

			function toggleAutoclicker() {
				if (autoclickerEnabled) {
					stopAutoclicker();
				} else {
					startAutoclicker();
				}
			}

			function startAutoclicker() {
				autoclickerEnabled = true;
				autoclickerInterval = setInterval(() => {
					player.shoot();
				}, 100);
				console.log("Autoclicker enabled. Press Ctrl to disable.");
			}

			function stopAutoclicker() {
				autoclickerEnabled = false;
				clearInterval(autoclickerInterval);
				console.log("Autoclicker disabled. Press Ctrl to enable.");
			}

			function checkCollisions() {
				projectiles.forEach((proj, projIndex) => {
					enemies.forEach((enemy, enemyIndex) => {
						if (
							proj.x > enemy.x &&
							proj.x < enemy.x + enemy.width &&
							proj.y > enemy.y &&
							proj.y < enemy.y + enemy.height
						) {
							projectiles.splice(projIndex, 1);
							enemies.splice(enemyIndex, 1);
							score += 100;
						}
					});
				});

				enemies.forEach((enemy) => {
					if (
						player.x < enemy.x + enemy.width &&
						player.x + player.width > enemy.x &&
						player.y < enemy.y + enemy.height &&
						player.y + player.height > enemy.y
					) {
						isGameOver = true;
					}
				});
			}

			function checkGameStatus() {
				if (enemies.length === 0) {
					if (level >= 10) {
						// Win after completing 10 levels
						isGameOver = true;
						ctx.fillStyle = "lime";
						ctx.font = "48px monospace";
						ctx.textAlign = "center";
						ctx.fillText(
							"You Win!",
							canvas.width / 2,
							canvas.height / 2
						);
						stopAutoclicker();
					} else {
						// Advance to next level
						nextLevel();
					}
				}
				enemies.forEach((enemy) => {
					if (enemy.y + enemy.height >= canvas.height) {
						isGameOver = true;
					}
				});
			}

			function drawScore() {
				ctx.fillStyle = "white";
				ctx.font = "24px monospace";
				ctx.textAlign = "left";
				ctx.fillText(`Score: ${score}`, 10, 30);
				ctx.fillText(`Level: ${level}`, 10, 60);

				// Draw autoclicker status
				const status = autoclickerEnabled
					? "Autoclicker: ON"
					: "Autoclicker: OFF";
				ctx.textAlign = "right";
				ctx.fillText(status, canvas.width - 10, 30);
			}

			function drawGameOver() {
				stopAutoclicker();
				ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = "red";
				ctx.font = "48px monospace";
				ctx.textAlign = "center";
				ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
				ctx.fillStyle = "white";
				ctx.font = "24px monospace";
				ctx.fillText(
					`Final Score: ${score}`,
					canvas.width / 2,
					canvas.height / 2 + 40
				);
				ctx.fillText(
					"Press 'Enter' to Restart",
					canvas.width / 2,
					canvas.height / 2 + 80
				);
			}

			function restartGame() {
				enemies = [];
				projectiles = [];
				init();
				animate();
			}

			function animate() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				if (isGameOver) {
					checkGameStatus();
					if (isGameOver) {
						drawGameOver();
						return;
					}
				}

				// Update and draw
				player.update();
				player.draw();

				projectiles.forEach((proj) => {
					proj.update();
					proj.draw();
				});

				enemies.forEach((enemy) => {
					enemy.update();
					enemy.draw();
				});

				checkCollisions();
				checkGameStatus();
				drawScore();

				// Filter out projectiles that have left the screen
				projectiles = projectiles.filter((proj) => 
					proj.x > -proj.radius && proj.x < canvas.width + proj.radius && 
					proj.y > -proj.radius && proj.y < canvas.height + proj.radius
				);

				requestAnimationFrame(animate);
			}

			// Initialize and start the game
			init();
			animate();
		</script>
	</body>
</html>

