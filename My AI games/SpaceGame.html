<!DOCTYPE html>
<html>
	<head>
		<title>Space Shooter</title>
		<style>
			body {
				background-color: black;
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				font-family: monospace;
				color: white;
				text-align: center;
			}
			canvas {
				background-color: #000;
				border: 2px solid white;
			}
			h1 {
				position: absolute;
				top: 50px;
				font-size: 3em;
				text-shadow: 2px 2px 5px #00f;
			}
		</style>
	</head>
	<body>
		<h1>Space Shooter</h1>
		<canvas id="gameCanvas" width="800" height="600"></canvas>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			// Game objects
			let player;
			let enemies = [];
			let projectiles = [];
			let score = 0;
			let isGameOver = false;
			let enemySpawnTimer = 0;
			let enemySpawnInterval = 120; // in frames

			const playerSpeed = 5;
			const projectileSpeed = 7;
			const enemySpeed = 1;
			const enemyRows = 4;
			const enemyCols = 8;
			const enemyPadding = 50;

			// Autoclicker variables
			let autoclickerEnabled = false;
			let autoclickerInterval;

			// Classes for game objects
			class Player {
				constructor() {
					this.width = 50;
					this.height = 30;
					this.x = canvas.width / 2 - this.width / 2;
					this.y = canvas.height - this.height - 20;
					this.speedX = 0;
				}

				draw() {
					ctx.fillStyle = "cyan";
					ctx.beginPath();
					ctx.moveTo(this.x, this.y + this.height);
					ctx.lineTo(this.x + this.width / 2, this.y);
					ctx.lineTo(this.x + this.width, this.y + this.height);
					ctx.closePath();
					ctx.fill();
				}

				update() {
					this.x += this.speedX;
					if (this.x < 0) this.x = 0;
					if (this.x + this.width > canvas.width)
						this.x = canvas.width - this.width;
				}

				shoot() {
					projectiles.push(
						new Projectile(
							this.x + this.width / 2,
							this.y,
							-projectileSpeed
						)
					);
				}
			}

			class Projectile {
				constructor(x, y, speedY) {
					this.x = x;
					this.y = y;
					this.radius = 3;
					this.speedY = speedY;
				}

				draw() {
					ctx.fillStyle = "white";
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
					ctx.fill();
				}

				update() {
					this.y += this.speedY;
				}
			}

			class Enemy {
				constructor(x, y) {
					this.width = 40;
					this.height = 30;
					this.x = x;
					this.y = y;
				}

				draw() {
					ctx.fillStyle = "red";
					ctx.fillRect(this.x, this.y, this.width, this.height);
				}

				update() {
					this.y += enemySpeed;
				}
			}

			function createEnemies() {
				const startX = (canvas.width - enemyCols * enemyPadding) / 2;
				for (let row = 0; row < enemyRows; row++) {
					for (let col = 0; col < enemyCols; col++) {
						enemies.push(
							new Enemy(
								startX + col * enemyPadding,
								row * enemyPadding + 50
							)
						);
					}
				}
			}

			function init() {
				player = new Player();
				enemies = [];
				projectiles = [];
				createEnemies();
				isGameOver = false;
				score = 0;
				// Ensure autoclicker is off on init
				stopAutoclicker();
			}

			// Input handling
			document.addEventListener("keydown", (e) => {
				if (isGameOver) {
					if (e.key === "Enter") {
						restartGame();
					}
					return;
				}
				if (e.key === "ArrowLeft") player.speedX = -playerSpeed;
				if (e.key === "ArrowRight") player.speedX = playerSpeed;
				if (e.key === " ") {
					e.preventDefault();
					if (!autoclickerEnabled) {
						// Only shoot if autoclicker isn't active
						player.shoot();
					}
				}
				if (e.key === "Control") {
					e.preventDefault();
					toggleAutoclicker();
				}
			});

			document.addEventListener("keyup", (e) => {
				if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
					player.speedX = 0;
				}
			});

			function toggleAutoclicker() {
				if (autoclickerEnabled) {
					stopAutoclicker();
				} else {
					startAutoclicker();
				}
			}

			function startAutoclicker() {
				autoclickerEnabled = true;
				autoclickerInterval = setInterval(() => {
					player.shoot();
				}, 100); // 100 milliseconds is a good speed
				console.log("Autoclicker enabled. Press Ctrl to disable.");
			}

			function stopAutoclicker() {
				autoclickerEnabled = false;
				clearInterval(autoclickerInterval);
				console.log("Autoclicker disabled. Press Ctrl to enable.");
			}

			function checkCollisions() {
				// Projectile vs Enemy
				projectiles.forEach((proj, projIndex) => {
					enemies.forEach((enemy, enemyIndex) => {
						if (
							proj.x > enemy.x &&
							proj.x < enemy.x + enemy.width &&
							proj.y > enemy.y &&
							proj.y < enemy.y + enemy.height
						) {
							projectiles.splice(projIndex, 1);
							enemies.splice(enemyIndex, 1);
							score += 100;
						}
					});
				});

				// Player vs Enemy
				enemies.forEach((enemy) => {
					if (
						player.x < enemy.x + enemy.width &&
						player.x + player.width > enemy.x &&
						player.y < enemy.y + enemy.height &&
						player.y + player.height > enemy.y
					) {
						isGameOver = true;
					}
				});
			}

			function checkGameStatus() {
				if (enemies.length === 0) {
					isGameOver = true;
					// Add a "You win!" state
					ctx.fillStyle = "lime";
					ctx.font = "48px monospace";
					ctx.textAlign = "center";
					ctx.fillText(
						"You Win!",
						canvas.width / 2,
						canvas.height / 2
					);
					stopAutoclicker();
				}
				enemies.forEach((enemy) => {
					if (enemy.y + enemy.height >= canvas.height) {
						isGameOver = true;
					}
				});
			}

			function drawScore() {
				ctx.fillStyle = "white";
				ctx.font = "24px monospace";
				ctx.fillText(`Score: ${score}`, 10, 30);
				// Draw autoclicker status
				const status = autoclickerEnabled
					? "Autoclicker: ON"
					: "Autoclicker: OFF";
				ctx.fillText(status, canvas.width - 250, 30);
			}

			function drawGameOver() {
				stopAutoclicker();
				ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.fillStyle = "red";
				ctx.font = "48px monospace";
				ctx.textAlign = "center";
				ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
				ctx.fillStyle = "white";
				ctx.font = "24px monospace";
				ctx.fillText(
					`Final Score: ${score}`,
					canvas.width / 2,
					canvas.height / 2 + 40
				);
				ctx.fillText(
					"Press 'Enter' to Restart",
					canvas.width / 2,
					canvas.height / 2 + 80
				);
			}

			function restartGame() {
				enemies = [];
				projectiles = [];
				init();
				animate();
			}

			function animate() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				if (isGameOver) {
					checkGameStatus();
					if (isGameOver) {
						if (enemies.length > 0) {
							drawGameOver();
						}
						return;
					}
				}

				// Update and draw
				player.update();
				player.draw();

				projectiles.forEach((proj) => {
					proj.update();
					proj.draw();
				});

				enemies.forEach((enemy) => {
					enemy.update();
					enemy.draw();
				});

				checkCollisions();
				checkGameStatus();
				drawScore();

				// Filter out old projectiles
				projectiles = projectiles.filter((proj) => proj.y > 0);

				requestAnimationFrame(animate);
			}

			// Initialize and start the game
			init();
			animate();
		</script>
	</body>
</html>
