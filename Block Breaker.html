<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Block Breaker</title>
		<style>
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				background-color: #1a1a1a;
				font-family: "Courier New", Courier, monospace;
				color: #fff;
			}

			.game-container {
				position: relative;
				border: 5px solid #fff;
				box-shadow: 0 0 30px #00ffff;
			}

			canvas {
				background: #000;
				display: block;
			}

			#pause-menu {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.7);
				color: #fff;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				font-size: 2em;
				text-align: center;
				pointer-events: none; /* Allows canvas events to pass through */
			}

			#pause-text {
				padding: 20px;
				border: 2px solid #fff;
				box-shadow: 0 0 15px #fff;
			}

			.hidden {
				display: none;
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<canvas id="gameCanvas" width="900" height="740"></canvas>
			<div id="pause-menu" class="hidden">
				<div id="pause-text">PAUSED<br />(Press ESC to resume)</div>
			</div>
		</div>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");
			const pauseMenu = document.getElementById("pause-menu");

			// Game variables
			const ballRadius = 6;
			let x = canvas.width / 2;
			let y = canvas.height - 30;
			let dx = 3;
			let dy = -3;
			const paddleHeight = 10;
			const paddleWidth = 85;
			let paddleX = (canvas.width - paddleWidth) / 2;
			let score = 0;
			let lives = 3;
			let isPaused = false;

			// Keyboard control variables
			let rightPressed = false;
			let leftPressed = false;

			// Brick variables
			const brickWidth = 35;
			const brickHeight = 15;
			const brickPadding = 5;
			const brickOffsetTop = 40;
			const brickOffsetLeft = 10;
			const brickColumnCount = Math.floor(
				(canvas.width - 2 * brickOffsetLeft) /
					(brickWidth + brickPadding)
			);
			const brickRowCount = Math.floor(
				(canvas.height * 0.4 - brickOffsetTop) /
					(brickHeight + brickPadding)
			);

			// Brick layout
			const bricks = [];
			for (let c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (let r = 0; r < brickRowCount; r++) {
					bricks[c][r] = { x: 0, y: 0, status: 1 };
				}
			}

			// Event listeners for keyboard
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			function keyDownHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight") {
					rightPressed = true;
				} else if (e.key === "Left" || e.key === "ArrowLeft") {
					leftPressed = true;
				} else if (e.key === "Escape") {
					isPaused = !isPaused; // Toggle pause state
					if (isPaused) {
						pauseMenu.classList.remove("hidden");
					} else {
						pauseMenu.classList.add("hidden");
						draw(); // Resume the game loop
					}
				}
			}

			function keyUpHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight") {
					rightPressed = false;
				} else if (e.key === "Left" || e.key === "ArrowLeft") {
					leftPressed = false;
				}
			}

			// Draw the ball
			function drawBall() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
				ctx.fillStyle = "#ff6347";
				ctx.fill();
				ctx.closePath();
			}

			// Draw the paddle
			function drawPaddle() {
				ctx.beginPath();
				ctx.rect(
					paddleX,
					canvas.height - paddleHeight,
					paddleWidth,
					paddleHeight
				);
				ctx.fillStyle = "#00ffff";
				ctx.fill();
				ctx.closePath();
			}

			// Draw bricks
			function drawBricks() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status === 1) {
							const brickX =
								c * (brickWidth + brickPadding) +
								brickOffsetLeft;
							const brickY =
								r * (brickHeight + brickPadding) +
								brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = `hsl(${
								(r / brickRowCount) * 360
							}, 80%, 60%)`;
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			// Collision detection
			function collisionDetection() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						const b = bricks[c][r];
						if (b.status === 1) {
							if (
								x > b.x &&
								x < b.x + brickWidth &&
								y > b.y &&
								y < b.y + brickHeight
							) {
								dy = -dy;
								b.status = 0;
								score++;
								if (
									score ===
									brickRowCount * brickColumnCount
								) {
									alert("Victory Royal! Congratulations!");
									document.location.reload();
								}
							}
						}
					}
				}
			}

			// Draw the score
			function drawScore() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#00ffff";
				ctx.fillText(`Score: ${score}`, 8, 25);
			}

			// Draw the lives counter
			function drawLives() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#ff6347";
				ctx.fillText(`Lives: ${lives}`, canvas.width - 90, 25);
			}

			// Main game loop
			function draw() {
				if (!isPaused) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					drawBricks();
					drawBall();
					drawPaddle();
					drawScore();
					drawLives();
					collisionDetection();

					// Wall collision logic
					if (
						x + dx > canvas.width - ballRadius ||
						x + dx < ballRadius
					) {
						dx = -dx;
					}
					if (y + dy < ballRadius) {
						dy = -dy;
					} else if (y + dy > canvas.height - ballRadius) {
						if (x > paddleX && x < paddleX + paddleWidth) {
							dy = -dy;
						} else {
							lives--;
							if (!lives) {
								alert("Game Over! Try again!");
								document.location.reload();
							} else {
								x = canvas.width / 2;
								y = canvas.height - 30;
								dx = 3;
								dy = -3;
								paddleX = (canvas.width - paddleWidth) / 2;
							}
						}
					}

					// Paddle movement logic
					if (rightPressed && paddleX < canvas.width - paddleWidth) {
						paddleX += 7;
					} else if (leftPressed && paddleX > 0) {
						paddleX -= 7;
					}

					// Move ball
					x += dx;
					y += dy;
				}

				requestAnimationFrame(draw);
			}

			draw();
		</script>
	</body>
</html>
