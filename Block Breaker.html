<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Block Breaker</title>
		<style>
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				background-color: #1a1a1a;
				font-family: "Courier New", Courier, monospace;
				color: #fff;
			}

			.game-container {
				position: relative;
				border: 5px solid #fff;
				box-shadow: 0 0 30px #00ffff;
			}

			canvas {
				background: #000;
				display: block;
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<canvas id="gameCanvas" width="900" height="740"></canvas>
		</div>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			// Ball properties
			const ballRadius = 6;
			const initialBallSpeed = 3;

			// Game variables
			const paddleHeight = 10;
			const paddleWidth = 85;
			let paddleX = (canvas.width - paddleWidth) / 2;
			let score = 0;
			let lives = 3;
			let isPaused = false;
			let balls = [];

			// Create Ball object
			class Ball {
				constructor(x, y, dx, dy, isOriginal = false) {
					this.x = x;
					this.y = y;
					this.dx = dx;
					this.dy = dy;
					this.radius = ballRadius;
					this.isOriginal = isOriginal;
				}
				draw() {
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
					ctx.fillStyle = this.isOriginal ? "#00ff00" : "#ff6347";
					ctx.fill();
					ctx.closePath();
				}
				move() {
					this.x += this.dx;
					this.y += this.dy;
				}
			}

			function resetGame() {
				balls = [];
				balls.push(
					new Ball(
						canvas.width / 2,
						canvas.height - 30,
						initialBallSpeed,
						-initialBallSpeed,
						true
					)
				);
				paddleX = (canvas.width - paddleWidth) / 2;
			}

			resetGame();

			// Keyboard control variables
			let rightPressed = false;
			let leftPressed = false;

			// Brick variables
			const brickWidth = 35;
			const brickHeight = 15;
			const brickPadding = 5;
			const brickOffsetTop = 40;
			const brickOffsetLeft = 10;
			const brickColumnCount = Math.floor(
				(canvas.width - 2 * brickOffsetLeft) /
					(brickWidth + brickPadding)
			);
			const brickRowCount = Math.floor(
				(canvas.height * 0.4 - brickOffsetTop) /
					(brickHeight + brickPadding)
			);

			// Brick layout
			const bricks = [];
			for (let c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (let r = 0; r < brickRowCount; r++) {
					bricks[c][r] = { x: 0, y: 0, status: 1 };
				}
			}

			// Event listeners for keyboard
			document.addEventListener("keydown", keyDownHandler, false);
			document.addEventListener("keyup", keyUpHandler, false);

			function keyDownHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight") {
					rightPressed = true;
				} else if (e.key === "Left" || e.key === "ArrowLeft") {
					leftPressed = true;
				} else if (e.key === "Escape") {
					isPaused = !isPaused; // Toggle pause state
				}
			}

			function keyUpHandler(e) {
				if (e.key === "Right" || e.key === "ArrowRight") {
					rightPressed = false;
				} else if (e.key === "Left" || e.key === "ArrowLeft") {
					leftPressed = false;
				}
			}

			// Draw the paddle
			function drawPaddle() {
				ctx.beginPath();
				ctx.rect(
					paddleX,
					canvas.height - paddleHeight,
					paddleWidth,
					paddleHeight
				);
				ctx.fillStyle = "#00ffff";
				ctx.fill();
				ctx.closePath();
			}

			// Draw bricks
			function drawBricks() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status === 1) {
							const brickX =
								c * (brickWidth + brickPadding) +
								brickOffsetLeft;
							const brickY =
								r * (brickHeight + brickPadding) +
								brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = `hsl(${
								(r / brickRowCount) * 360
							}, 80%, 60%)`;
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			// Collision detection
			function collisionDetection() {
				for (let i = 0; i < balls.length; i++) {
					const ball = balls[i];
					for (let c = 0; c < brickColumnCount; c++) {
						for (let r = 0; r < brickRowCount; r++) {
							const b = bricks[c][r];
							if (b.status === 1) {
								if (
									ball.x > b.x &&
									ball.x < b.x + brickWidth &&
									ball.y > b.y &&
									ball.y < b.y + brickHeight
								) {
									ball.dy = -ball.dy;
									b.status = 0;
									score++;

									// 1 in 4 chance to spawn a new ball if the ORIGINAL ball hits a block
									if (
										ball.isOriginal &&
										Math.random() < 0.25
									) {
										const newBall = new Ball(
											ball.x,
											ball.y,
											Math.random() * 6 - 3,
											Math.random() * 6 - 3
										);
										balls.push(newBall);
									}

									if (
										score ===
										brickRowCount * brickColumnCount
									) {
										alert(
											"Victory Royal! Congratulations!"
										);
										document.location.reload();
									}
								}
							}
						}
					}
				}
			}

			// Draw the score
			function drawScore() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#00ffff";
				ctx.fillText(`Score: ${score}`, 8, 25);
			}

			// Draw the lives counter
			function drawLives() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#ff6347";
				ctx.fillText(`Lives: ${lives}`, canvas.width - 90, 25);
			}

			// Main game loop
			function draw() {
				if (!isPaused) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					drawBricks();
					drawPaddle();
					drawScore();
					drawLives();
					collisionDetection();

					for (let i = 0; i < balls.length; i++) {
						const ball = balls[i];
						ball.draw();
						ball.move();

						// Wall collision logic
						if (
							ball.x + ball.dx > canvas.width - ball.radius ||
							ball.x + ball.dx < ball.radius
						) {
							ball.dx = -ball.dx;
						}
						if (ball.y + ball.dy < ball.radius) {
							ball.dy = -ball.dy;
						} else if (
							ball.y + ball.dy >
							canvas.height - ball.radius
						) {
							if (
								ball.x > paddleX &&
								ball.x < paddleX + paddleWidth
							) {
								ball.dy = -ball.dy;
							} else {
								balls.splice(i, 1); // Remove ball from the array
								i--; // Decrement the counter to account for the removed ball

								// Check if any balls are left. If not, lose a life and reset.
								if (balls.length === 0) {
									lives--;
									if (!lives) {
										alert("Game Over! Try again!");
										document.location.reload();
									} else {
										// Respawn a new original ball
										resetGame();
									}
								}
							}
						}
					}

					// Paddle movement logic
					if (rightPressed && paddleX < canvas.width - paddleWidth) {
						paddleX += 7;
					} else if (leftPressed && paddleX > 0) {
						paddleX -= 7;
					}
				}

				requestAnimationFrame(draw);
			}

			draw();
		</script>
	</body>
</html>
