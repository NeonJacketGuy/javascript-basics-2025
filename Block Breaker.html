<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Block Breaker</title>
		<style>
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				margin: 0;
				background-color: #1a1a1a;
				font-family: "Courier New", Courier, monospace;
				color: #fff;
			}

			.game-container {
				border: 5px solid #fff;
				box-shadow: 0 0 30px #00ffff;
			}

			canvas {
				background: #000;
				display: block;
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<canvas id="gameCanvas" width="900" height="740"></canvas>
		</div>
		<script>
			const canvas = document.getElementById("gameCanvas");
			const ctx = canvas.getContext("2d");

			// Game variables
			const ballRadius = 6; // Smaller ball
			let x = canvas.width / 2;
			let y = canvas.height - 30;
			let dx = 3;
			let dy = -3;
			const paddleHeight = 10;
			const paddleWidth = 85;
			let paddleX = (canvas.width - paddleWidth) / 2;
			let score = 0;
			let lives = 3;

			// Brick variables
			const brickWidth = 35; // Smaller brick width
			const brickHeight = 15;
			const brickPadding = 5; // Smaller padding
			const brickOffsetTop = 40;
			const brickOffsetLeft = 10;

			// Calculate brick columns and rows based on canvas size
			const brickColumnCount = Math.floor(
				(canvas.width - 2 * brickOffsetLeft) /
					(brickWidth + brickPadding)
			);
			const brickRowCount = Math.floor(
				(canvas.height * 0.4 - brickOffsetTop) /
					(brickHeight + brickPadding)
			);

			// Brick layout
			const bricks = [];
			for (let c = 0; c < brickColumnCount; c++) {
				bricks[c] = [];
				for (let r = 0; r < brickRowCount; r++) {
					bricks[c][r] = { x: 0, y: 0, status: 1 };
				}
			}

			// Event listener for paddle movement
			document.addEventListener("mousemove", mouseMoveHandler, false);

			function mouseMoveHandler(e) {
				const relativeX = e.clientX - canvas.offsetLeft;
				if (relativeX > 0 && relativeX < canvas.width) {
					paddleX = relativeX - paddleWidth / 2;
				}
			}

			// Draw the ball
			function drawBall() {
				ctx.beginPath();
				ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
				ctx.fillStyle = "#ff6347"; // Tomato color
				ctx.fill();
				ctx.closePath();
			}

			// Draw the paddle
			function drawPaddle() {
				ctx.beginPath();
				ctx.rect(
					paddleX,
					canvas.height - paddleHeight,
					paddleWidth,
					paddleHeight
				);
				ctx.fillStyle = "#00ffff"; // Cyan color
				ctx.fill();
				ctx.closePath();
			}

			// Draw bricks
			function drawBricks() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						if (bricks[c][r].status === 1) {
							const brickX =
								c * (brickWidth + brickPadding) +
								brickOffsetLeft;
							const brickY =
								r * (brickHeight + brickPadding) +
								brickOffsetTop;
							bricks[c][r].x = brickX;
							bricks[c][r].y = brickY;
							ctx.beginPath();
							ctx.rect(brickX, brickY, brickWidth, brickHeight);
							ctx.fillStyle = `hsl(${
								(r / brickRowCount) * 360
							}, 80%, 60%)`; // Color bricks by row
							ctx.fill();
							ctx.closePath();
						}
					}
				}
			}

			// Collision detection
			function collisionDetection() {
				for (let c = 0; c < brickColumnCount; c++) {
					for (let r = 0; r < brickRowCount; r++) {
						const b = bricks[c][r];
						if (b.status === 1) {
							if (
								x > b.x &&
								x < b.x + brickWidth &&
								y > b.y &&
								y < b.y + brickHeight
							) {
								dy = -dy;
								b.status = 0;
								score++;
								if (
									score ===
									brickRowCount * brickColumnCount
								) {
									alert("Victory Royal! Congratulations!");
									document.location.reload();
								}
							}
						}
					}
				}
			}

			// Draw the score
			function drawScore() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#00ffff";
				ctx.fillText(`Score: ${score}`, 8, 25);
			}

			// Draw the lives counter
			function drawLives() {
				ctx.font = "18px 'Courier New'";
				ctx.fillStyle = "#ff6347";
				ctx.fillText(`Lives: ${lives}`, canvas.width - 90, 25);
			}

			// Main game loop
			function draw() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawBricks();
				drawBall();
				drawPaddle();
				drawScore();
				drawLives();
				collisionDetection();

				// Wall collision logic
				if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
					dx = -dx;
				}
				if (y + dy < ballRadius) {
					dy = -dy;
				} else if (y + dy > canvas.height - ballRadius) {
					if (x > paddleX && x < paddleX + paddleWidth) {
						dy = -dy;
					} else {
						lives--;
						if (!lives) {
							alert("Game Over! Try again!");
							document.location.reload();
						} else {
							x = canvas.width / 2;
							y = canvas.height - 30;
							dx = 3;
							dy = -3;
							paddleX = (canvas.width - paddleWidth) / 2;
						}
					}
				}

				// Move ball
				x += dx;
				y += dy;

				requestAnimationFrame(draw);
			}

			draw();
		</script>
	</body>
</html>
